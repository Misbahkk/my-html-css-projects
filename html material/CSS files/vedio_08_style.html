<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>style</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="box">
        <h1>Computers</h1>
        <p>made the process of developing a program simpler and more understandable, and less bound to the underlying
            hardware. The first compiler related tool, the A-0 System, was developed in 1952[12] by Grace Hopper, who
            also coined the term 'compiler'.[13][14] FORTRAN, the first widely used high-level language to have a
            functional implementation, came out in 1957,[15] and many other languages were soon developed—in particular,
            COBOL aimed at commercial data processing, and Lisp for computer research.

            These compiled languages allow the programmer to write programs in terms that are syntactically richer, and
            more capable of abstracting the code, making it easy to target for varying machine instruction sets via
            compilation declarations and heuristics. Compilers harnessed the power of computers to make programming
            easier[15] by allowing programmers to specify calculations by entering a formula using infix notation.

        </p>
        <h1>Machine language</h1>
        <p>was the language of early programs, written in the instruction set of the particular machine, often in binary notation. Assembly languages were soon developed that let the programmer specify instruction in a text
            format (e.g., ADD X, TOTAL), with abbreviations for each operation code and meaningful names for specifying
            addresses. However, because an assembly language is little more than a different notation for a machine
            language, two machines with different instruction sets also have different assembly languages.</p>
        <h1>Algorithmic complexity</h1>
        <p>The academic field and the engineering practice of computer programming are both largely concerned with
            discovering and implementing the most efficient algorithms for a given class of problems. For this purpose,
            algorithms are classified into orders using so-called Big O notation, which expresses resource use, such as
            execution time or memory consumption, in terms of the size of an input.
            Expert programmers are familiar with a variety of well-established algorithms and their respective
            complexities and use this knowledge to choose algorithms that are best suited to the circumstances.</p>

        <h1>Methodologies</h1>
        <p>The first step in most formal software development processes is requirements analysis, followed by testing to
            determine value modeling, implementation, and failure elimination (debugging). There exist a lot of
            different approaches for each of those tasks. One approach popular for requirements analysis is Use Case
            analysis. Many programmers use forms of Agile software development where the various stages of formal
            software development are more integrated together into short cycles that take a few weeks rather than years.
            There are many approaches to the Software development process.

            Popular modeling techniques include Object-Oriented Analysis and Design (OOAD) and Model-Driven Architecture
            (MDA). The Unified Modeling Language (UML) is a notation used for both the OOAD and MDA.

            A similar technique used for database design is Entity-Relationship Modeling (ER Modeling).

            Implementation techniques include imperative languages (object-oriented or procedural), functional
            languages, and logic languages.

        </p>
        <h1>Computers</h1>
        <p>made the process of developing a program simpler and more understandable, and less bound to the underlying
            hardware. The first compiler related tool, the A-0 System, was developed in 1952[12] by Grace Hopper, who
            also coined the term 'compiler'.[13][14] FORTRAN, the first widely used high-level language to have a
            functional implementation, came out in 1957,[15] and many other languages were soon developed—in particular,
            COBOL aimed at commercial data processing, and Lisp for computer research.

            These compiled languages allow the programmer to write programs in terms that are syntactically richer, and
            more capable of abstracting the code, making it easy to target for varying machine instruction sets via
            compilation declarations and heuristics. Compilers harnessed the power of computers to make programming
            easier[15] by allowing programmers to specify calculations by entering a formula using infix notation.

        </p>
        <h1>Machine language</h1>
        <p>was the language of early programs, written in the instruction set of the particular machine, often in binary
            notation. Assembly languages were soon developed that let the programmer specify instruction in a text
            format (e.g., ADD X, TOTAL), with abbreviations for each operation code and meaningful names for specifying
            addresses. However, because an assembly language is little more than a different notation for a machine
            language, two machines with different instruction sets also have different assembly languages.</p>
        <h1>Algorithmic complexity</h1>
        <p>The academic field and the engineering practice of computer programming are both largely concerned with
            discovering and implementing the most efficient algorithms for a given class of problems. For this purpose,
            algorithms are classified into orders using so-called Big O notation, which expresses resource use, such as
            execution time or memory consumption, in terms of the size of an input.
            Expert programmers are familiar with a variety of well-established algorithms and their respective
            complexities and use this knowledge to choose algorithms that are best suited to the circumstances.</p>

        <h1>Methodologies</h1>
        <p>The first step in most formal software development processes is requirements analysis, followed by testing to
            determine value modeling, implementation, and failure elimination (debugging). There exist a lot of
            different approaches for each of those tasks. One approach popular for requirements analysis is Use Case
            analysis. Many programmers use forms of Agile software development where the various stages of formal
            software development are more integrated together into short cycles that take a few weeks rather than years.
            There are many approaches to the Software development process.

            Popular modeling techniques include Object-Oriented Analysis and Design (OOAD) and Model-Driven Architecture
            (MDA). The Unified Modeling Language (UML) is a notation used for both the OOAD and MDA.

            A similar technique used for database design is Entity-Relationship Modeling (ER Modeling).

            Implementation techniques include imperative languages (object-oriented or procedural), functional
            languages, and logic languages.

        </p>
        <h1>Computers</h1>
        <p>made the process of developing a program simpler and more understandable, and less bound to the underlying
            hardware. The first compiler related tool, the A-0 System, was developed in 1952[12] by Grace Hopper, who
            also coined the term 'compiler'.[13][14] FORTRAN, the first widely used high-level language to have a
            functional implementation, came out in 1957,[15] and many other languages were soon developed—in particular,
            COBOL aimed at commercial data processing, and Lisp for computer research.

            These compiled languages allow the programmer to write programs in terms that are syntactically richer, and
            more capable of abstracting the code, making it easy to target for varying machine instruction sets via
            compilation declarations and heuristics. Compilers harnessed the power of computers to make programming
            easier[15] by allowing programmers to specify calculations by entering a formula using infix notation.

        </p>
        <h1>Machine language</h1>
        <p>was the language of early programs, written in the instruction set of the particular machine, often in binary
            notation. Assembly languages were soon developed that let the programmer specify instruction in a text
            format (e.g., ADD X, TOTAL), with abbreviations for each operation code and meaningful names for specifying
            addresses. However, because an assembly language is little more than a different notation for a machine
            language, two machines with different instruction sets also have different assembly languages.</p>
        <h1>Algorithmic complexity</h1>
        <p>The academic field and the engineering practice of computer programming are both largely concerned with
            discovering and implementing the most efficient algorithms for a given class of problems. For this purpose,
            algorithms are classified into orders using so-called Big O notation, which expresses resource use, such as
            execution time or memory consumption, in terms of the size of an input.
            Expert programmers are familiar with a variety of well-established algorithms and their respective
            complexities and use this knowledge to choose algorithms that are best suited to the circumstances.</p>

        <h1>Methodologies</h1>
        <p>The first step in most formal software development processes is requirements analysis, followed by testing to
            determine value modeling, implementation, and failure elimination (debugging). There exist a lot of
            different approaches for each of those tasks. One approach popular for requirements analysis is Use Case
            analysis. Many programmers use forms of Agile software development where the various stages of formal
            software development are more integrated together into short cycles that take a few weeks rather than years.
            There are many approaches to the Software development process.

            Popular modeling techniques include Object-Oriented Analysis and Design (OOAD) and Model-Driven Architecture
            (MDA). The Unified Modeling Language (UML) is a notation used for both the OOAD and MDA.

            A similar technique used for database design is Entity-Relationship Modeling (ER Modeling).

            Implementation techniques include imperative languages (object-oriented or procedural), functional
            languages, and logic languages.

        </p>
    </div>
</body>

</html>